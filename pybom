#!/usr/bin/python3

import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
from tkinter import messagebox

from Inventory import *
from UIComponents import EditItemPopup, MenuBar


class InventoryTable(tk.Frame):
    def __init__(self, parent, frame):
        tk.Frame.__init__(self)
        self.frame = tk.Frame(frame)
        self.parent = parent
        self.createInventoryTable()

    def createInventoryTable(self):
        actionFrame = tk.Frame(self.frame)
        tk.Button(actionFrame, text='Add', command=self.addButtonHandler).pack(side='left', padx=10)
        tk.Button(actionFrame, text='Edit', command=self.editButtonHandler).pack(side='left', padx=10)
        tk.Button(actionFrame, text='Delete', command=self.deleteButtonHandler).pack(side='left', padx=10)
        tk.Button(actionFrame, text='Export', command=self.exportButtonHandler).pack(side='left', padx=10)
        actionFrame.pack(side='top', pady=10)

        self.treeview = tv = ttk.Treeview(self.frame)
        ts = ttk.Scrollbar(self.frame)

        ts.configure(command=tv.yview)
        tv.configure(yscrollcommand=ts.set)

        tv['columns'] = ('MFRPN', 'MFR', 'FOOTPRINT', 'DESCRIPTION', 'STOCK')
        tv.heading("#0", text='ID', anchor='w')
        tv.column("#0", anchor="w", width=50)

        tv.heading('MFRPN', text='Manufacturer Part No')
        tv.column('MFRPN', anchor='w', width=200)
        tv.heading('MFR', text='Manufacturer')
        tv.column('MFR', anchor='w', width=150)
        tv.heading('FOOTPRINT', text='Footprint')
        tv.column('FOOTPRINT', anchor='w', width=100)
        tv.heading('DESCRIPTION', text='Description')
        tv.column('DESCRIPTION', anchor='w', width=350)
        tv.heading('STOCK', text='Stock')
        tv.column('STOCK', anchor='e', width=50)

        tv.bind("<Double-1>", self.editButtonHandler)
        tv.bind("<Escape>", self.dropSelection)
        tv.bind("<Delete>", self.deleteButtonHandler)
        tv.pack(side='left', fill='both', expand=1)
        ts.pack(side='right', fill='y')
        self.frame.pack(fill='both', expand=1)

    def dropSelection(self, event):
        for index in self.treeview.selection():
            self.treeview.selection_remove(index)

    def editButtonHandler(self, event=None):
        index = self.treeview.selection()[0]
        item = self.getSelectedItems()[0]
        self.editItem(index, item)

    def deleteButtonHandler(self, event=None):
        selection = self.treeview.selection()
        if not selection:
            return
        result = messagebox.askquestion("Delete", "Are You Sure? "
            "The selected items will be removed permanently!", icon='warning')
        if result == 'yes':
            # first remove from DB
            items = self.getSelectedItems()
            itemIDList = []
            for item in items:
                itemIDList.append(item.item['ID'])
            self.parent.itemMgr.deleteItems(tuple(itemIDList))
            # now remove from table
            for index in selection:
                self.treeview.delete(index)

    def exportButtonHandler(self):
        try:
            file = filedialog.asksaveasfilename()
            itemList = self.getSelectedItems()
            self.parent.itemMgr.exportItemsToCSV(file, itemList)
        except Exception as err:
            messagebox.showinfo("Error", err)

    def addButtonHandler(self):
        item = Item()
        editWindow = EditItemPopup(self, item)
        self.parent.wait_window(editWindow.top)
        if editWindow.mItem is not None:
            try:
                newID = self.parent.itemMgr.insertItem(editWindow.mItem)
                editWindow.mItem.item['ID'] = newID
                self.insertItem('end', editWindow.mItem)
            except Exception as err:
                messagebox.showinfo("Error", err)

    def editItem(self, index, item):
        editWindow = EditItemPopup(self, item)
        self.parent.wait_window(editWindow.top)
        if editWindow.mItem is not None:
            self.updateSelection(index, editWindow.mItem)
            self.parent.itemMgr.updateItem(editWindow.mItem)

    def getSelectedItems(self):
        selList = self.treeview.selection()
        itemList = []
        for sel in selList:
            valList = []
            valList = self.treeview.item(sel)['values']
            valList.insert(0, self.treeview.item(sel)['text'])
            itemList.append(Item(valList))
        return itemList

    def updateSelection(self, index, item):
        pos = self.treeview.index(index)
        self.treeview.delete(index)
        self.insertItem(pos, item)

    def insertItem(self, pos, item):
        records=item.getRecords()
        self.treeview.insert('', pos, text=records[0], values=records[1:])

    def insertItemList(self, itemList):
        for item in itemList:
            self.insertItem('end', item)

    def flushRecords(self):
        self.treeview.delete(*self.treeview.get_children())


class App(tk.Tk):
    def __init__(self):
        tk.Tk.__init__(self)
        self.configure()
        self.nb = ttk.Notebook(self)
        self.itemMgr = ItemManager(self)
        self.menubar = MenuBar(self)
        self.config(menu=self.menubar)
        
        invFrame = tk.Frame(self)
        self.iTable = InventoryTable(self, invFrame)
        self.nb.add(invFrame, text="Inventory")

        editFrame = tk.Frame(self)
        sString = tk.StringVar()
        tk.Label(editFrame, text="Search" ).grid(row=0, column=0, sticky='w', pady=3, padx=10)
        tk.Entry(editFrame, width=32, textvariable=sString).grid(row=0, column=1, padx=10)
        ttk.Button(editFrame, text='Search', command=(lambda: self.searchTable(
            sString.get()))).grid(row=0, column=2, sticky='w', padx=10)
        editFrame.pack(side='top', pady=20)
        self.nb.add(editFrame, text="Edit")
        self.nb.pack(fill='both', expand=1, padx=3, pady=3)

        try:
            self.itemMgr.openDatabase('item.DB')
            itemList = self.itemMgr.getInventoryItemList()
            self.iTable.insertItemList(itemList)
            print('Loaded defalut DB..')
        except Exception as err:
            print("Default DB error: " + str(err))

    def openDatabase(self):
        try:
            name = filedialog.askopenfilename()
            self.itemMgr.openDatabase(name)
            self.table.flushRecords()
            itemList = self.itemMgr.getInventoryItemList()
            self.iTable.insertItemList(itemList)
        except Exception as err:
            self.showError(err)
        
    def createDatabase(self):
        try:
            name = filedialog.asksaveasfilename()
            self.itemMgr.createDatabase(name)
        except Exception as err:
            self.showError(err)

    def importInventory(self):
        try:
            self.itemMgr.importInventoryFromCSV(filedialog.askopenfilename())
            self.iTable.flushRecords()
            itemList = self.itemMgr.getInventoryItemList()
            self.iTable.insertItemList(itemList)
        except Exception as err:
            self.showError(err)

    def exportInventory(self):
        self.itemMgr.exportInventoryToCSV(filedialog.asksaveasfilename())   
        
    def configure(self):
        # config stuffs
        self.title("PyBom")
        self.geometry("1200x600+100+100")

    def showError(self, msg):
        messagebox.showinfo("Error", msg)


if __name__ == "__main__":
    app=App()
    app.mainloop()
