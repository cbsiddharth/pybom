#!/usr/bin/python3

import csv
import os
import sqlite3
import time
from pprint import pprint as pprint
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
from tkinter import messagebox
import sys

class DatabaseManager(object):
    def __init__(self, db):
        self.conn = sqlite3.connect(db)
        self.conn.execute('pragma foreign_keys = on')
        self.conn.commit()
        self.cur = self.conn.cursor()

    def query(self, arg):
        self.cur.execute(arg)
        self.conn.commit()
        return self.cur

    def __del__(self):
        self.conn.close()

class Item:
    def __init__(self, itemList=None):
        self.item = self.make_dict(list(itemList))

    def __str__(self):
        return "'%d', '%s', '%s', '%s', '%s', %s" % ( self.item['ID'], self.item['MFRPN'], self.item['MFR'], self.item['FOOTPRINT'],
                self.item['DESCRIPTION'], self.item['STOCK'] )

    @staticmethod
    def getPrototype():
        return ['ID', 'MFRPN', 'MFR', 'FOOTPRINT', 'DESCRIPTION', 'STOCK']

    def getItemList(self):
        return [ self.item['ID'], self.item['MFRPN'], self.item['MFR'], self.item['FOOTPRINT'],
                self.item['DESCRIPTION'], self.item['STOCK'] ]

    def getStrInsertDB(self):
        return "null, '%s', '%s', '%s', '%s', %s" % ( self.item['MFRPN'], self.item['MFR'], self.item['FOOTPRINT'],
                self.item['DESCRIPTION'], self.item['STOCK'] )

    def make_dict(self, itemList):
        if len(Item.getPrototype()) != len(itemList):
            print ("->" + str(Item.getPrototype()))
            print ("<-" + str(itemList))
            raise Exception("Inalid item entry!")
        else:
            itemList[0] = int(itemList[0])
            itemList[5] = int(itemList[5])
            return dict(zip(Item.getPrototype(), itemList))


class ItemManager:
    def __init__(self, parent):
        self.parent = parent
    
    def openDatabase(self, dbFile):
        db = DatabaseManager(dbFile)
        try:
            tables = db.query("SELECT name FROM sqlite_master WHERE type='table';", ).fetchone();
        except sqlite3.DatabaseError:
            raise Exception('Invlaid Inventory File!')

        inventory = []
        for table in tables:
            found=1
            db.query("SELECT * FROM %s;" % table)
            fieldnames=[f[0] for f in db.cur.description]
            if len(fieldnames) != len(Item.getPrototype()):
                found = 0
            else:
                for val in Item.getPrototype():
                    if val not in fieldnames:
                        found = 0
            if found == 1:
                inventory.append(table)

        if len(inventory) == 0:
            raise Exception("Doesn't look like a valid inverntory file")
            return

        self.dbFile = dbFile
        
    def loadInventoryTable(self, table):
        db = DatabaseManager(self.dbFile)
        rows = db.query("SELECT * FROM INVENTORY;").fetchall()
        for row in rows:
            item = Item(row)
            table.insertItem(item)

    def createDatabase(self, dbFile):
        db = DatabaseManager(dbFile)
        db.query('CREATE TABLE IF NOT EXISTS INVENTORY (ID INTEGER PRIMARY KEY AUTOINCREMENT,'
            ' MFRPN NOT NULL, MFR TEXT, FOOTPRINT TEXT, DESCRIPTION TEXT, STOCK INT NOT NULL);')
        self.dbFile = dbFile

    def insertItemToInventory(self, itemList):
        db = DatabaseManager(self.dbFile)
        for item in itemList:
            db.query('INSERT OR IGNORE INTO INVENTORY VALUES (%s);' % item.getStrInsertDB())

    def importInventoryFromCSV(self, filename):
        try:
            itemList = []
            with open(filename, 'r') as f:
                rows = csv.reader(f, delimiter=',', quotechar='"')
                for row in rows:
                    if (row != Item.getPrototype()):
                        itemList.append(Item(row))
            self.insertItemToInventory(itemList)

        except EnvironmentError:
            print('File error: %s' % filename)


    def exportInventoryToCSV(self, filename):
        db = DatabaseManager(self.dbFile)
        rows = db.query("SELECT * FROM INVENTORY;")
        with open(filename, 'w') as f:
            wfd = csv.writer(f, delimiter=',', quotechar='"')
            wfd.writerow(Item.getPrototype())
            wfd.writerows(rows)

##########################################################################################################3

class MenuBar(tk.Menu):
    exportFileName = ""
    importFileName = ""
    dbFileName = ""
    def __init__(self, parent):
        self.parent = parent
        tk.Menu.__init__(self, parent)

        filemenu = tk.Menu(self, tearoff=False)
        self.add_cascade(label="File",underline=0, menu=filemenu)
        filemenu.add_command(label="New Database",  underline=0, command=self.parent.createDatabase)
        filemenu.add_command(label="Open Database", underline=0, command=self.parent.openDatabase)

        filemenu.add_separator()
        filemenu.add_command(label="Exit", underline=1, command=self.quit)

        toolsmenu = tk.Menu(self, tearoff=False)
        self.add_cascade(label="Tools",underline=0, menu=toolsmenu)
        toolsmenu.add_command(label="Export Inventory", underline=0, command=self.parent.exportInventory)
        toolsmenu.add_command(label="Import Inventory", underline=0, command=self.parent.importInventory)
        
        helpmenu = tk.Menu(self, tearoff=False)
        self.add_cascade(label="Help",underline=0, menu=helpmenu)
        helpmenu.add_command(label="About", underline=0, command=self.showAbout)

    def quit(self):
        sys.exit(0)

    def showAbout(self):
        toplevel = tk.Toplevel()
        toplevel.title("About pyBOM")
        ABOUT_TEXT = """
        pyBOM is a light weight, BOM (Bill Of Materials) and
        inventory management tool for the electronic stock keeping units.

        Siddharth Chandrasekaran
        siddharth@embedjournal.com"""
        tk.Label(toplevel, text=ABOUT_TEXT, height=10, width=80).pack(fill='both', padx=20)


class Table(tk.Frame):
    def __init__(self, parent):
        tk.Frame.__init__(self)
        self.parent = parent
        self.createInventoryTable()
        
    def createInventoryTable(self):
        tv = ttk.Treeview(self.parent)
        ts = ttk.Scrollbar(self.parent)

        ts.configure(command=tv.yview)
        tv.configure(yscrollcommand=ts.set)

        tv['columns'] = ('MFRPN', 'MFR', 'FOOTPRINT', 'DESCRIPTION', 'STOCK')
        tv.heading("#0", text='ID', anchor='w')
        tv.column("#0", anchor="w", width=50)

        tv.heading('MFRPN', text='MManufacturer Part No')
        tv.column('MFRPN', anchor='w', width=200)
        tv.heading('MFR', text='Manufacturer')
        tv.column('MFR', anchor='w', width=150)
        tv.heading('FOOTPRINT', text='Footprint')
        tv.column('FOOTPRINT', anchor='w', width=100)
        tv.heading('DESCRIPTION', text='Description')
        tv.column('DESCRIPTION', anchor='w', width=350)
        tv.heading('STOCK', text='Stock')
        tv.column('STOCK', anchor='e', width=50)
        tv.pack(side='left', fill='both', expand=1)
        ts.pack(side='right', fill='y')
        self.treeview = tv

    def insertItem(self, item):
        records=item.getItemList()
        self.treeview.insert('', 'end', text=records[0], values=records[1:])

    def flushRecords(self):
        self.treeview.delete(*self.treeview.get_children())


class App(tk.Tk):
    def __init__(self):
        tk.Tk.__init__(self)
        self.configure()
        self.nb = ttk.Notebook(self)
        self.itemMgr = ItemManager(self)
        self.menubar = MenuBar(self)
        self.config(menu=self.menubar)
        
        invFrame = tk.Frame(self)
        self.table = Table(invFrame)
        self.nb.add(invFrame, text="Inventory")

        editFrame = tk.Frame(self)
        sString = tk.StringVar()
        tk.Label(editFrame, text="Search" ).grid(row=0, column=0, sticky='w', pady=3, padx=10)
        tk.Entry(editFrame, width=32, textvariable=sString).grid(row=0, column=1, padx=10)
        ttk.Button(editFrame, text='Search', command=(lambda: self.searchTable(sString.get()))).grid(row=0, column=2, sticky='w', padx=10)
        editFrame.pack(side='top', pady=20)
        self.nb.add(editFrame, text="Edit")
        
        self.nb.pack(fill='both', expand=1, padx=3, pady=3)

    def openDatabase(self):
        try:
            name = filedialog.askopenfilename()
            self.itemMgr.openDatabase(name)
            self.table.flushRecords()
            self.itemMgr.loadInventoryTable(self.table)
        except Exception as err:
            self.showError(err)
        
    def createDatabase(self):
        try:
            name = filedialog.asksaveasfilename()
            self.itemMgr.createDatabase(name)
        except Exception as err:
            self.showError(err)

    def importInventory(self):
        try:
            self.itemMgr.importInventoryFromCSV(filedialog.askopenfilename())
            self.table.flushRecords()
            self.itemMgr.loadInventoryTable(self.table)
        except Exception as err:
            self.showError(err)

    def exportInventory(self):
        self.itemMgr.exportInventoryToCSV(filedialog.asksaveasfilename())   
        
    def configure(self):
        # config stuffs
        self.title("PyBom")
        self.geometry("1200x600+100+100")

    def showError(self, msg):
        messagebox.showinfo("Error", msg)
        
if __name__ == "__main__":
    app=App()
    app.mainloop()
